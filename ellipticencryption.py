# -*- coding: utf-8 -*-
"""ellipticencryption.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nZrR0FQGhjMDDfeUEnOf1Cy6nekOkf4Y

# Encriptacion con Curvas Elipticas
## TecnolÃ³gico de Monterrey
## Escuela de Ingenieria y Ciencias

---
### Profesor: Dr. Juan Salvador Garza Ledesma
### Rafael Barroso P.
### (A01662031)
---

### **A continuacion se muestra el codigo necesario para programar la ley del grupo de curvas elipticas sobre un campo finito (i.e. $\mathbb{Z}_p$):**

**Funcion para invertir un numero en un campo finito (Nuestro marido Fermat):**
"""

def inv_mod(n,p):
	""" Encontrar el inverso de k mop p (Tu marido Fermat)"""
	""" n^{p-1} equiv 1 (mod p) --> n x n^{p-2} equiv 1 (mod p) """

	if n == 0:
		raise ZeroDivisionError("Error, no existe inverso de 0")

	return pow(n, p-2, p) # n^{p-2} es el inverso modular de a mod p

"""**Esta es la funcion mas choncha, utilizada para sumar cualesquier dos puntos en la curva eliptica:**"""

def suMOTA(P, Q, a, p):
	if P is None:
		return Q

	if Q is None:
		return P

	if P == Q:
		if P[1] == 0:
			return None # Punto se duplica al infinito

		s = (3 * P[0]**2 + a) * inv_mod(2 * P[1], p) % p

	else:
		if P[0] == Q[0]:
			return None # Son inversos --> resultado es el punto al infinito

		s = (Q[1] - P[1]) * inv_mod(Q[0] - P[0], p) % p

	x3 = (s**2 - P[0] - Q[0]) % p
	y3 = (s * (P[0] - x3) - P[1]) % p

	return (x3, y3)

"""**Funcion para suma repetida de un punto (o dos) en la curva eliptica (i.e. $\alpha(A + B)$, $\alpha \in \mathbb{N}$):**"""

def suMOTOTA(P, a, n, p, Q=None):
	''' Suma de un punto (o dos) muchas veces '''

	if Q is not None:
		P = suMOTA(P,Q,a,p)

	vaina = None
	sumando = P

	while n > 0:
		if n % 2 == 1:
			vaina = suMOTA(vaina, sumando, a, p)
		sumando = suMOTA(sumando, sumando, a, p)
		n //= 2

	return vaina

"""**Funcion para invertir un punto en la curva eliptica (i.e. $-A$):**"""

def inv_puntitties(P, p):
	if P is None:
		return None

	return (P[0], -P[1] % p)

"""**Funcion para generar todos los puntos de la curva eliptica:**"""

def gen_puntitties(a, b, p):
	puntitties = []

	for x in range(p):
		ye_cuad = (x**3 + a*x + b) % p # Eq. de la curvita sabrosonga

		for y in range(p):
			if (y*y) % p == ye_cuad:
				puntitties.append((x, y))

	puntitties.append(None) # Agregamos punto a la verga

	return puntitties

"""**En la siguiente celda se muestra la funcion que crea el diccionario a partir de los puntos de la curva eliptica.**"""

def dictionario(puntos_curvita_sabrosonga):
	''' Mapeo de puntos de la curva a alphanumerico '''

	import string
	letritas_y_numeritos = string.ascii_uppercase + string.ascii_lowercase + string.digits

	if len(puntos_curvita_sabrosonga) < len(letritas_y_numeritos):
		raise ValueError('Error, no hay suficientes puntos en la curva')

	diK = {}
	for i, char in enumerate(letritas_y_numeritos):
		diK[puntos_curvita_sabrosonga[i]] = char

	return diK

"""**Finalmente, hacemos una funcion pa desenctiptar cadenas de caracteres:**"""

def tedescubro(E1, E2, alpha, B1, Ba, a, p):

    alpha_E1 = suMOTOTA(E1, a, alpha, p)
    alpha_B1 = suMOTOTA(B1, a, alpha, p)

    restita = suMOTA(alpha_E1, alpha_B1, a, p)
    restita = suMOTA(restita, Ba, a, p)

    M = suMOTA(E2, inv_puntitties(restita, p), a, p)

    return M

"""**A verdad... ahora si ya esta es la ultima funcion y la mas mamalona. Esta sirve para desencriptar oraciones (a perro) dadas dos listas de puntos E1 y E2.**"""

def MAMALONA(E1_list, E2_list, alpha, B1, Ba, a, p, dK):

    mensaje_descifrado = []

    for E1, E2 in zip(E1_list, E2_list):

        M = tedescubro(E1, E2, alpha, B1, Ba, a, p)


        if M in dK:
            mensaje_descifrado.append(dK[M])
        else:
            mensaje_descifrado.append('?')

    return ''.join(mensaje_descifrado)

"""Ahora si, vamos a encriptar!"""

## Inicializamos parametros
p = 709
a, b = 24 % p, 24 % p

## Generamos puntos en la curva
puntitties = gen_puntitties(a, b, p)

## Generamos diccionario
diK = dictionario(puntitties)

import json

def guardar_diK(diK, nombre):

    diK_convertido = {str(key): value for key, value in diK.items()}

    with open(nombre, 'w') as file:
        json.dump(diK_convertido, file, indent=4)

    print(f"Dictionary saved to {nombre}")

guardar_diK(diK, 'diK.json')

"""Contestando la pregunta de examen... Cuantos puntos tiene $\epsilon$ en el campo $\mathbb{Z}_{709}$:"""

print(len(puntitties))

## Cosas pa encriptar

punto_comun = (708,613) # Publico

alpha = 4 # Privado
punto_rafiki = (708, 96) # Privado


# Se lo mando a G
A_1 = suMOTOTA(punto_rafiki, a, alpha, p, punto_comun)
A_2 = suMOTOTA(punto_rafiki, a, alpha, p)
print(A_1)
print(A_2)